---
phase: 01-parsers-data-models
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/parsers/sodexo.py
  - backend/tests/fixtures/sodexo/hoch_2026-02-07.html
  - backend/tests/test_sodexo_parser.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Running the Sodexo parser returns structured menu data for Hoch-Shanahan with station groupings and dietary tags"
    - "Parser extracts meals (breakfast/lunch/dinner/brunch) with stations and items from Sodexo JSON-in-HTML"
    - "Dietary tags (vegan, vegetarian, mindful) are correctly extracted from Sodexo item boolean fields"
    - "Station filtering matches v1: hidden stations removed, stations ordered, truncation applied, aliases merged"
    - "Parser unit tests pass against saved HTML fixture without network calls"
  artifacts:
    - path: "backend/app/parsers/sodexo.py"
      provides: "SodexoParser implementation"
      contains: "class SodexoParser"
      exports: ["SodexoParser"]
    - path: "backend/tests/test_sodexo_parser.py"
      provides: "Sodexo parser unit tests"
      contains: "def test_"
    - path: "backend/tests/fixtures/sodexo/hoch_2026-02-07.html"
      provides: "Saved HTML fixture for offline testing"
  key_links:
    - from: "backend/app/parsers/sodexo.py"
      to: "backend/app/parsers/base.py"
      via: "inherits BaseParser"
      pattern: "class SodexoParser\\(BaseParser\\)"
    - from: "backend/app/parsers/sodexo.py"
      to: "backend/app/parsers/station_filters.py"
      via: "uses SODEXO_FILTER and apply_station_filters"
      pattern: "apply_station_filters.*SODEXO_FILTER"
    - from: "backend/tests/test_sodexo_parser.py"
      to: "backend/app/parsers/sodexo.py"
      via: "tests parse() with fixture HTML"
      pattern: "parser\\.parse"
---

<objective>
Implement the Sodexo parser for Hoch-Shanahan dining hall with extraction from JSON-in-HTML, station filtering, dietary tags, and fixture-based unit tests.

Purpose: Sodexo is the simplest vendor (structured JSON embedded in HTML). Completing it validates the base parser pattern and station filter pipeline before tackling the more complex BAMCO and Pomona parsers.

Output: Working SodexoParser, saved HTML fixture, passing unit tests.
</objective>

<execution_context>
@/Users/felixpeng/.claude/get-shit-done/workflows/execute-plan.md
@/Users/felixpeng/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-parsers-data-models/01-CONTEXT.md
@.planning/phases/01-parsers-data-models/01-RESEARCH.md
@.planning/phases/01-parsers-data-models/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SodexoParser and save fixture</name>
  <files>
    backend/app/parsers/sodexo.py
    backend/tests/fixtures/sodexo/hoch_2026-02-07.html
  </files>
  <action>
    1. Create `backend/app/parsers/sodexo.py` with `SodexoParser(BaseParser)`:

       **Constructor:**
       - Call `super().__init__(hall_id, hall_name)`
       - Store URL template. Sodexo URL format: `https://menus.sodexomyway.com/BiteMenu/MenuOnly?menuId=15258&locationId=13147001&startdate={MM/DD/YYYY}`
       - The hall_id for Hoch is "hoch", hall_name is "Hoch-Shanahan"

       **`build_url(self, target_date: date) -> str`:**
       - Format date as MM/DD/YYYY for the `startdate` parameter
       - Return the full Sodexo URL

       **`async def fetch_raw(self, target_date: date) -> str`:**
       - Use httpx.AsyncClient with User-Agent header, follow_redirects=True, timeout=30s
       - GET the built URL
       - Raise on HTTP errors
       - Return response.text

       **`def parse(self, raw_content: str, target_date: date) -> ParsedMenu`:**
       This is the pure parsing logic (no I/O). Steps:

       a. Extract JSON from HTML:
          - Primary: Use selectolax LexborHTMLParser to find `#nutData` div, get its text content
          - Fallback: regex `r'<div[^>]*id\s*=\s*["\']nutData["\'][^>]*>(.*?)</div>'` with re.DOTALL
          - Parse extracted text as JSON (json.loads)
          - If extraction fails, raise ValueError with descriptive message

       b. The JSON is an array of day objects. Each day has:
          - `date`: date string
          - `dayParts`: array of meal objects, each with:
            - `dayPartName`: "Breakfast", "Lunch", "Dinner", "Brunch"
            - `courses`: array of station objects, each with:
              - `courseName`: station name (raw, needs normalization)
              - `menuItems`: array of items, each with:
                - `formalName`: item name
                - `description`: item description
                - `isVegan`: bool
                - `isVegetarian`: bool
                - `isMindful`: bool
                - `calories`: string (parse to int)

       c. For each day in the JSON array:
          - Parse the date string to match target_date (Sodexo returns a week of data; filter to requested date)
          - For each dayPart (meal):
            - For each course (station):
              - Normalize station name using `normalize_sodexo_station_name()` from station_filters
              - Apply station merging (tryFindMerged equivalent using SODEXO_FILTER.combined)
              - Skip items with empty formalName (after stripping whitespace)
              - Extract dietary tags: check isVegan, isVegetarian, isMindful booleans, map to canonical tags using DIETARY_TAG_MAP
              - Build ParsedMenuItem for each item
              - Build ParsedStation (merging items into existing station if same name already seen in this meal)
            - Apply `apply_station_filters` with `SODEXO_FILTER` to the stations list
            - Build ParsedMeal with lowercase meal name
          - Build ParsedMenu for the target_date

       d. If target_date not found in JSON, return ParsedMenu with empty meals list

       **Important v1 behaviors to replicate:**
       - Station name normalization: strip "SCR" suffix, ucwords if ALL CAPS, fix "And"/"To"/"Hmc"
       - Blank/dash station names -> "Miscellaneous"
       - Stations with same name after merging: combine their items (don't create duplicate stations)
       - Empty "Miscellaneous" stations are dropped (v1: `if stationName == "miscellaneous" && count(menu) == 0, continue`)
       - Truncation of -1 means hide entirely

    2. Save a fixture file:
       - Fetch the live Sodexo page: `python -c "import httpx; r = httpx.get('https://menus.sodexomyway.com/BiteMenu/MenuOnly?menuId=15258&locationId=13147001&startdate=02/07/2026', headers={'User-Agent': 'Mozilla/5.0'}, follow_redirects=True, timeout=30); open('backend/tests/fixtures/sodexo/hoch_2026-02-07.html', 'w').write(r.text); print(f'Saved {len(r.text)} bytes')"`
       - If the live fetch fails (network issue, site down), create a minimal synthetic fixture that matches the expected JSON-in-HTML structure with at least 2 meals, 3+ stations per meal, and items with dietary flags. Include a `<div id="nutData">` wrapper around the JSON array.
       - Name the fixture with the date: `hoch_YYYY-MM-DD.html`
  </action>
  <verify>
    - `cd /Users/felixpeng/Downloads/repos/5c-menu/backend && python -c "from app.parsers.sodexo import SodexoParser; print('SodexoParser imports OK')"` succeeds
    - `ls backend/tests/fixtures/sodexo/` shows at least one .html fixture file
    - `cd /Users/felixpeng/Downloads/repos/5c-menu/backend && python -c "
from app.parsers.sodexo import SodexoParser
from datetime import date
import json

parser = SodexoParser('hoch', 'Hoch-Shanahan')
with open('tests/fixtures/sodexo/hoch_2026-02-07.html') as f:
    html = f.read()
# Use the date that matches the fixture
menu = parser.parse(html, date(2026, 2, 7))
print(f'Meals: {len(menu.meals)}')
for meal in menu.meals:
    print(f'  {meal.meal}: {len(meal.stations)} stations')
    for station in meal.stations[:2]:
        print(f'    {station.name}: {len(station.items)} items')
        if station.items:
            print(f'      First item: {station.items[0].name}, tags: {station.items[0].tags}')
print('Parse test OK')
"` shows meals with stations and items
  </verify>
  <done>
    - SodexoParser inherits BaseParser with fetch_raw and parse implemented
    - parse() extracts JSON from nutData div, processes day/meal/station/item hierarchy
    - Station names normalized (SCR stripped, ucwords, Miscellaneous for blanks)
    - Dietary tags extracted from boolean fields
    - Station filter pipeline applied (hidden, truncated, ordered, combined)
    - At least one HTML fixture file saved for offline testing
  </done>
</task>

<task type="auto">
  <name>Task 2: Sodexo parser unit tests</name>
  <files>
    backend/tests/test_sodexo_parser.py
  </files>
  <action>
    Create `backend/tests/test_sodexo_parser.py` with pytest tests against the saved fixture:

    1. **Fixture setup:**
       - `@pytest.fixture` that reads the saved HTML fixture file and returns raw HTML string
       - `@pytest.fixture` that creates a SodexoParser instance for "hoch"

    2. **Test: parse returns valid menu structure** (`test_sodexo_parse_returns_menu`):
       - Call `parser.parse(fixture_html, date_matching_fixture)`
       - Assert result is a ParsedMenu
       - Assert `menu.hall_id == "hoch"`
       - Assert `len(menu.meals) >= 1` (at least one meal period)

    3. **Test: meals have stations with items** (`test_sodexo_meals_have_stations`):
       - Parse fixture
       - For each meal, assert `len(meal.stations) >= 1`
       - For the first station, assert `len(station.items) >= 1`
       - Assert all item names are non-empty strings

    4. **Test: hidden stations are removed** (`test_sodexo_hidden_stations_filtered`):
       - Parse fixture
       - Collect all station names (lowercase) across all meals
       - Assert none of SODEXO_FILTER.hidden appear in the result
       - Specifically check "salad bar", "deli bar", "hot cereal" are absent

    5. **Test: station ordering matches v1** (`test_sodexo_station_ordering`):
       - Parse fixture
       - For any meal with 2+ stations, check that stations appearing in ORDERED_STATIONS are in the correct relative order

    6. **Test: truncation applied** (`test_sodexo_truncation`):
       - Parse fixture
       - If a "Grill" station exists in any meal, assert len(items) <= 3
       - If a "Breakfast" station exists in breakfast meal, assert len(items) <= 12

    7. **Test: dietary tags extracted** (`test_sodexo_dietary_tags`):
       - Parse fixture
       - Collect all tags from all items across all meals
       - Assert at least some items have tags (the fixture should have vegan/vegetarian items)
       - Assert all tags are from the canonical set: {"vegan", "vegetarian", "mindful", "gluten-free", "halal", "balanced", "farm-to-fork", "humane"}

    8. **Test: station name normalization** (`test_sodexo_station_name_normalization`):
       - Test the normalize_sodexo_station_name function directly:
         - "EXHIBITION SCR" -> "Exhibition"
         - "PASTA/NOODLES" -> "Pasta/Noodles"
         - "  " -> "Miscellaneous"
         - "-" -> "Miscellaneous"
         - "Chef's Corner" -> "Chef's Corner" (no change needed)

    9. **Test: validate detects empty menu** (`test_sodexo_validate_empty`):
       - Create ParsedMenu with no meals
       - Assert `parser.validate(empty_menu)` returns False

    10. **Test: combined stations are merged** (`test_sodexo_combined_stations`):
        - Create a list of ParsedStations with alias names (e.g., "stew" and "soup")
        - Run through apply_station_filters with SODEXO_FILTER
        - Assert they are merged into "Soups" with combined items

    Ensure all tests work WITHOUT network calls -- only using fixture files.
  </action>
  <verify>
    `cd /Users/felixpeng/Downloads/repos/5c-menu/backend && python -m pytest tests/test_sodexo_parser.py -v` -- all tests pass
  </verify>
  <done>
    - All Sodexo parser tests pass against fixture HTML
    - Tests cover: structure, station filtering (hidden/ordered/truncated/combined), dietary tags, name normalization, validation
    - Zero network calls in tests
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_sodexo_parser.py -v` -- all tests pass
- SodexoParser can parse the fixture and produce structured meals with filtered stations
- Dietary tags are extracted and normalized
- Station filtering matches v1 PHP behavior
</verification>

<success_criteria>
- SodexoParser.parse() takes raw HTML and returns ParsedMenu with correct meals/stations/items
- Hidden stations (salad bar, deli bar, etc.) are removed
- Stations are sorted per v1 ORDERED_STATIONS list
- Grill truncated to 3 items, breakfast to 12, etc.
- Combined stations merged (stew+soup -> Soups, etc.)
- Dietary tags (vegan, vegetarian, mindful) extracted from Sodexo boolean fields
- All tests pass against saved fixture without network
</success_criteria>

<output>
After completion, create `.planning/phases/01-parsers-data-models/01-02-SUMMARY.md`
</output>
