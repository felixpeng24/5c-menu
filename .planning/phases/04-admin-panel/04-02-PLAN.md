---
phase: 04-admin-panel
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/app/routers/admin.py
  - backend/app/services/hours_service.py
  - backend/app/parsers/fallback.py
autonomous: true

must_haves:
  truths:
    - "GET /api/v2/admin/hours returns all dining hours entries for the hours grid"
    - "PUT /api/v2/admin/hours/{id} updates a single hours entry and returns the updated record"
    - "POST /api/v2/admin/hours creates a new hours entry"
    - "DELETE /api/v2/admin/hours/{id} removes an hours entry"
    - "GET /api/v2/admin/overrides returns all overrides"
    - "POST /api/v2/admin/overrides creates a new override"
    - "PUT /api/v2/admin/overrides/{id} updates an override"
    - "DELETE /api/v2/admin/overrides/{id} removes an override"
    - "GET /api/v2/admin/health returns parser health summary per hall"
    - "Parser executions are recorded in the parser_runs table"
  artifacts:
    - path: "backend/app/routers/admin.py"
      provides: "Hours CRUD, overrides CRUD, health query endpoints"
      contains: "list_hours"
    - path: "backend/app/parsers/fallback.py"
      provides: "Parser health instrumentation in get_menu_with_fallback"
      contains: "ParserRun"
  key_links:
    - from: "backend/app/routers/admin.py"
      to: "backend/app/models/dining_hours.py"
      via: "SQLModel queries for DiningHours, DiningHoursOverride"
      pattern: "DiningHours|DiningHoursOverride"
    - from: "backend/app/routers/admin.py"
      to: "backend/app/models/parser_run.py"
      via: "SQLAlchemy aggregation query for health summary"
      pattern: "ParserRun"
    - from: "backend/app/parsers/fallback.py"
      to: "backend/app/models/parser_run.py"
      via: "Records ParserRun on each parser execution"
      pattern: "ParserRun"
---

<objective>
Add CRUD endpoints for hours management, overrides management, and parser health dashboard to the admin router. Instrument the parser fallback system to record execution history for health monitoring.

Purpose: These endpoints provide the data layer that the admin frontend pages will consume. The parser health instrumentation is the source of truth for ADM-04.

Output: Complete admin API with hours CRUD (ADM-02), overrides CRUD (ADM-03), health summary (ADM-04), and parser instrumentation.
</objective>

<execution_context>
@/Users/felixpeng/.claude/get-shit-done/workflows/execute-plan.md
@/Users/felixpeng/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-admin-panel/04-RESEARCH.md
@.planning/phases/04-admin-panel/04-01-SUMMARY.md

@backend/app/routers/admin.py
@backend/app/models/dining_hours.py
@backend/app/models/parser_run.py
@backend/app/schemas/admin.py
@backend/app/services/auth_service.py
@backend/app/services/hours_service.py
@backend/app/parsers/fallback.py
@backend/app/dependencies.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hours and overrides CRUD endpoints</name>
  <files>
    backend/app/routers/admin.py
  </files>
  <action>
Add CRUD endpoints to the existing admin router (which already has auth endpoints from Plan 01). All endpoints require `Depends(require_admin)` and `Depends(get_session)`.

**Hours CRUD:**

1. `GET /hours` — Query all `DiningHours` rows ordered by `hall_id`, `day_of_week`, `meal`. Return `list[HoursResponse]`. Convert `start_time`/`end_time` from `datetime.time` to ISO string (`t.isoformat()`).

2. `POST /hours` — Accept `HoursCreate` body. Parse `start_time`/`end_time` strings to `datetime.time` using `datetime.time.fromisoformat()`. Create new `DiningHours` row. Return `HoursResponse` with 201 status.

3. `PUT /hours/{hours_id}` — Accept `HoursUpdate` body. Fetch `DiningHours` by ID, raise 404 if not found. Update only provided (non-None) fields. Convert time strings to `datetime.time` if provided. Commit and return `HoursResponse`.

4. `DELETE /hours/{hours_id}` — Fetch `DiningHours` by ID, raise 404 if not found. Delete and return `{"message": "Deleted"}`.

**Overrides CRUD:**

5. `GET /overrides` — Query all `DiningHoursOverride` rows ordered by `date` descending. Return `list[OverrideResponse]`. Convert `date` to ISO string, `start_time`/`end_time` to ISO string or None.

6. `POST /overrides` — Accept `OverrideCreate` body. Parse `date` from string using `datetime.date.fromisoformat()`. Parse `start_time`/`end_time` if provided. Create `DiningHoursOverride` row. Return `OverrideResponse` with 201.

7. `PUT /overrides/{override_id}` — Accept `OverrideUpdate` body. Fetch by ID, raise 404 if not found. Update provided fields, commit, return `OverrideResponse`.

8. `DELETE /overrides/{override_id}` — Fetch by ID, raise 404 if not found. Delete and return `{"message": "Deleted"}`.

Import needed types:
```python
import datetime as _dt
from sqlmodel import select
from app.models.dining_hours import DiningHours, DiningHoursOverride
from app.schemas.admin import (
    HoursResponse, HoursUpdate, HoursCreate,
    OverrideResponse, OverrideCreate, OverrideUpdate,
)
```

Helper function to convert a DiningHours row to HoursResponse:
```python
def _hours_to_response(h: DiningHours) -> HoursResponse:
    return HoursResponse(
        id=h.id,
        hall_id=h.hall_id,
        day_of_week=h.day_of_week,
        meal=h.meal,
        start_time=h.start_time.isoformat(),
        end_time=h.end_time.isoformat(),
        is_active=h.is_active,
    )
```

Similar helper for overrides:
```python
def _override_to_response(o: DiningHoursOverride) -> OverrideResponse:
    return OverrideResponse(
        id=o.id,
        hall_id=o.hall_id,
        date=o.date.isoformat(),
        meal=o.meal,
        start_time=o.start_time.isoformat() if o.start_time else None,
        end_time=o.end_time.isoformat() if o.end_time else None,
        reason=o.reason,
    )
```
  </action>
  <verify>
    Run `cd backend && python -c "from app.main import app; routes = [r.path for r in app.routes]; hrs = [r for r in routes if 'hours' in r or 'overrides' in r]; print(hrs)"` — confirm hours and overrides routes registered.
    Run `cd backend && python -m pytest tests/ -x -q` — existing tests still pass.
  </verify>
  <done>
    Admin router has GET/POST/PUT/DELETE for /hours and /overrides.
    All endpoints require authentication via require_admin dependency.
    Time/date conversion uses isoformat() for responses and fromisoformat() for requests.
    Existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Parser health endpoint and fallback instrumentation</name>
  <files>
    backend/app/routers/admin.py
    backend/app/parsers/fallback.py
  </files>
  <action>
1. **backend/app/routers/admin.py** — Add the health summary endpoint:

   `GET /health` — Query `ParserRun` table for the last 24 hours. Use SQLAlchemy `func` for aggregation:
   ```python
   from sqlalchemy import func, case
   from app.models.parser_run import ParserRun
   from app.schemas.admin import ParserHealthResponse
   ```

   Query pattern (from research):
   ```python
   cutoff = _dt.datetime.now(_dt.timezone.utc) - _dt.timedelta(hours=24)
   stmt = (
       select(
           ParserRun.hall_id,
           func.max(
               case(
                   (ParserRun.status == "success", ParserRun.started_at),
                   else_=None,
               )
           ).label("last_success"),
           func.count().label("total_runs"),
           func.sum(
               case((ParserRun.status != "success", 1), else_=0)
           ).label("error_count"),
       )
       .where(ParserRun.started_at >= cutoff)
       .group_by(ParserRun.hall_id)
   )
   ```

   Map results to `list[ParserHealthResponse]`. Set `error_rate = round(error_count / total_runs * 100, 1)` if `total_runs > 0`, else `0.0`. Format `last_success` as ISO string or None.

2. **backend/app/parsers/fallback.py** — Instrument `get_menu_with_fallback` to record ParserRun entries.

   Add instrumentation **inside** the existing function (not a wrapper). This avoids changing the function signature or any callers.

   At the top of `get_menu_with_fallback`, record `start = time.monotonic()`. Add `import time` at module top.

   Import `from app.models.parser_run import ParserRun`.

   After the try/except block (in the success path and exception path), create a ParserRun record:
   - On success (fresh data): `status="success"`, `duration_ms=int((time.monotonic() - start) * 1000)`, `menu_date=target_date`
   - On parser exception: `status="error"`, `error_message=str(exc)[:500]`
   - On fallback (parser returned None): `status="no_data"`
   - On fallback loaded from DB: `status="fallback"`

   Record the ParserRun via `session.add(run)` and `await session.commit()`. Wrap the instrumentation in its own try/except so recording failures never break the menu flow — if recording fails, log a warning and continue.

   The modified function structure should be:
   ```python
   async def get_menu_with_fallback(...):
       start = time.monotonic()
       status = "success"
       error_msg = None

       try:
           menu = await parser.fetch_and_parse(target_date)
           if menu is not None:
               now = _dt.datetime.now(_dt.timezone.utc)
               await persist_menu(session, hall_id, target_date, menu)
               # Record success
               _record_run(session, hall_id, target_date, start, "success")
               return menu, False, now
           status = "no_data"
       except Exception as exc:
           logger.warning(...)
           status = "error"
           error_msg = str(exc)[:500]

       # Record non-success
       await _record_run(session, hall_id, target_date, start, status, error_msg)

       # Fallback: load from DB
       stored_menu, stored_fetched_at = await load_latest_menu(...)
       if stored_menu is not None:
           return stored_menu, True, stored_fetched_at
       return None, True, None
   ```

   Create a helper `_record_run` async function that wraps ParserRun creation in try/except to never break the flow:
   ```python
   async def _record_run(session, hall_id, target_date, start, status, error_message=None):
       try:
           duration_ms = int((time.monotonic() - start) * 1000)
           run = ParserRun(
               hall_id=hall_id, duration_ms=duration_ms,
               status=status, error_message=error_message,
               menu_date=target_date,
           )
           session.add(run)
           await session.commit()
       except Exception:
           logger.warning("Failed to record parser run for %s", hall_id, exc_info=True)
   ```

   **Important:** The success path records and commits before returning. For the success case, `persist_menu` already commits, so the `_record_run` commit is a separate transaction. This is fine — ParserRun records are best-effort telemetry, not transactional with menu data.
  </action>
  <verify>
    Run `cd backend && python -c "from app.parsers.fallback import get_menu_with_fallback; print('Instrumented OK')"` — fallback module imports without errors.
    Run `cd backend && python -c "from app.main import app; routes = [r.path for r in app.routes]; print([r for r in routes if 'health' in r])"` — health endpoint registered.
    Run `cd backend && python -m pytest tests/ -x -q` — existing tests still pass (instrumentation wrapped in try/except won't break fallback tests).
  </verify>
  <done>
    GET /health endpoint returns per-hall health summary (last_success, total_runs_24h, error_count_24h, error_rate).
    get_menu_with_fallback records ParserRun entries for each execution (success, error, no_data, fallback).
    Instrumentation is wrapped in try/except so it never breaks the menu fetch flow.
    Existing parser/fallback tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && python -c "from app.main import app; routes = [r.path for r in app.routes]; admin = [r for r in routes if 'admin' in r]; print(admin)"` — all admin routes visible
2. `cd backend && python -m pytest tests/ -x -q` — no test regressions
3. `cd backend && python -c "from app.parsers.fallback import get_menu_with_fallback; print('OK')"` — fallback imports cleanly with instrumentation
</verification>

<success_criteria>
- Admin router has complete CRUD for hours (4 endpoints) and overrides (4 endpoints)
- Health endpoint returns aggregated parser run data
- Parser fallback records execution history in parser_runs table
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-admin-panel/04-02-SUMMARY.md`
</output>
